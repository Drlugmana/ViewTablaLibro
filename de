[HttpGet("latest")]
public async Task<ActionResult<PagedResponse<ProblemDynatraceResponse>>> GetProblemsLatest(
    [FromQuery] int pageNumber = 1,
    [FromQuery] int pageSize = 50,
    [FromQuery] string? jurisdiction = null
)
{
    var now = DateTime.Now;

    // CLOSED recientes (ayer + hoy)
    var closedFrom = DateTime.Today.AddDays(-1);

    // Si no mandan jurisdiction, por defecto trabajamos con TCS (tu caso real)
    var tcsJurisdiction = string.IsNullOrWhiteSpace(jurisdiction) ? "TCS" : jurisdiction.Trim();

    // === Query principal (TCS): OPEN + CLOSED recientes ===
    var tcsQuery = _context.DynatraceProblems
        .AsNoTracking()
        .Where(p =>
            p.Jurisdiction == tcsJurisdiction &&
            (
                p.Status == "OPEN"
                || (p.Status == "CLOSED" && p.EndTime != null && p.EndTime >= closedFrom)
            )
            && p.StartTime < now
        );

    // === Query extra (NO TCS): solo los más recientes ===
    // Nota: aquí "NO TCS" depende de cómo lo tengas guardado:
    // - Jurisdiction == "NO TCS"  (si lo guardas así)
    // - o Jurisdiction != "TCS"   (si todo lo demás es "no tcs")
    // Te lo dejo como != TCS para que agarre todos los no-TCS.
    var noTcsQuery = _context.DynatraceProblems
        .AsNoTracking()
        .Where(p =>
            p.Jurisdiction != "TCS" &&
            p.Status == "OPEN" &&
            p.StartTime < now
        );

    // Unimos ambos: TCS + NoTCS
    var baseQuery = tcsQuery.Concat(noTcsQuery);

    // Orden: OPEN primero, y dentro por StartTime DESC
    baseQuery = baseQuery
        .OrderByDescending(p => p.Status == "OPEN")
        .ThenByDescending(p => p.StartTime);

    var totalRecords = await baseQuery.CountAsync();

    var problems = await baseQuery
        .Skip((pageNumber - 1) * pageSize)
        .Take(pageSize)
        .ToListAsync();

    // Mantener tu misma lógica de deserialización
    var deserializedProblems = problems
        .Select(problem =>
        {
            try
            {
                return convertProblemJSON(problem);
            }
            catch (JsonException)
            {
                return null;
            }
        })
        .Where(p => p != null)
        .ToList()!;

    var response = new PagedResponse<ProblemDynatraceResponse>
    {
        TotalRecords = totalRecords,
        TotalPages = (int)Math.Ceiling(totalRecords / (double)pageSize),
        PageNumber = pageNumber,
        PageSize = pageSize,
        Data = deserializedProblems
    };

    return response;
}