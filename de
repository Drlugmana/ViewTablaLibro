using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using System.Reflection;
using System.Text.Json;

namespace RestAPIDynatrace.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class ProblemsController : ControllerBase
    {
        private readonly AppDbContext _context;

        public ProblemsController(AppDbContext context)
        {
            _context = context;
        }

        // =========================
        // HELPERS (NO CAMBIAN TU DTO)
        // =========================
        private static void TrySet<T>(T obj, string propName, object? value)
        {
            var prop = typeof(T).GetProperty(
                propName,
                BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase
            );

            if (prop == null || !prop.CanWrite) return;

            var targetType = Nullable.GetUnderlyingType(prop.PropertyType) ?? prop.PropertyType;

            if (value == null)
            {
                prop.SetValue(obj, null);
                return;
            }

            if (targetType.IsAssignableFrom(value.GetType()))
            {
                prop.SetValue(obj, value);
                return;
            }

            try
            {
                prop.SetValue(obj, Convert.ChangeType(value, targetType));
            }
            catch
            {
                // si no puede convertir, no setea y listo (no rompe)
            }
        }

        // ‚ö†Ô∏è Si tu entidad EF NO se llama DynatraceProblem, cambia este tipo aqu√≠:
        private static ProblemDynatraceResponse BuildMinimalResponse(DynatraceProblem p)
        {
            var r = new ProblemDynatraceResponse();

            // Setea lo que exista en tu DTO (sin romper compilaci√≥n)
            TrySet(r, "ProblemId", p.ProblemId);
            TrySet(r, "Id", p.ProblemId);

            TrySet(r, "DisplayId", p.DisplayId);
            TrySet(r, "Title", p.Title);
            TrySet(r, "Status", p.Status);
            TrySet(r, "Jurisdiction", p.Jurisdiction);

            TrySet(r, "StartTime", p.StartTime);
            TrySet(r, "EndTime", p.EndTime);

            // opcionales (si existen en tu DTO)
            TrySet(r, "Environment", p.Environment);
            TrySet(r, "Tenant", p.Tenant);
            TrySet(r, "ImpactLevel", p.ImpactLevel);
            TrySet(r, "SeverityLevel", p.SeverityLevel);
            TrySet(r, "ShortDescription", p.ShortDescription);

            return r;
        }

        // ==========================================
        // ‚úÖ ENDPOINT COMPLETO CORREGIDO (LATEST)
        // ==========================================
        [HttpGet("latest")]
        public async Task<ActionResult<PagedResponse<ProblemDynatraceResponse>>> GetProblemsLatest(
            [FromQuery] int pageNumber = 1,
            [FromQuery] int pageSize = 50,
            [FromQuery] string? jurisdiction = null
        )
        {
            // AYER 00:00 (hora del servidor)
            var startDate = DateTime.Today.AddDays(-1);

            // AHORA
            var endDate = DateTime.Now;

            // ‚ö†Ô∏è Si tu DBSet NO se llama _context.DynatraceProblems, c√°mbialo aqu√≠:
            var baseQuery = _context.DynatraceProblems
                .AsNoTracking()
                .Where(p => p.StartTime >= startDate && p.StartTime <= endDate);

            if (!string.IsNullOrWhiteSpace(jurisdiction))
            {
                baseQuery = baseQuery.Where(p => p.Jurisdiction == jurisdiction);
            }

            // orden: m√°s recientes primero
            baseQuery = baseQuery.OrderByDescending(p => p.StartTime);

            var totalRecords = await baseQuery.CountAsync();

            var problems = await baseQuery
                .Skip((pageNumber - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            // ‚úÖ NO se pierden alertas por JSON inv√°lido
            var deserializedProblems = new List<ProblemDynatraceResponse>(problems.Count);

            foreach (var problem in problems)
            {
                try
                {
                    var mapped = convertProblemJSON(problem);

                    // si tu convert devuelve null, igual la devolvemos m√≠nimo
                    deserializedProblems.Add(mapped ?? BuildMinimalResponse(problem));
                }
                catch (JsonException)
                {
                    // ‚úÖ no se pierde el registro
                    deserializedProblems.Add(BuildMinimalResponse(problem));
                }
                catch
                {
                    // por seguridad: cualquier otro error tambi√©n devuelve m√≠nimo
                    deserializedProblems.Add(BuildMinimalResponse(problem));
                }
            }

            var response = new PagedResponse<ProblemDynatraceResponse>
            {
                TotalRecords = totalRecords,
                TotalPages = (int)Math.Ceiling(totalRecords / (double)pageSize),
                PageNumber = pageNumber,
                PageSize = pageSize,
                Data = deserializedProblems
            };

            return response;
        }

        // =====================================================
        // TU M√âTODO EXISTENTE (NO LO CAMBIO, SOLO LO USO)
        // =====================================================
        private ProblemDynatraceResponse? convertProblemJSON(DynatraceProblem problem)
        {
            // üëá aqu√≠ va TU implementaci√≥n actual (d√©jala tal cual)
            throw new NotImplementedException();
        }
    }
}